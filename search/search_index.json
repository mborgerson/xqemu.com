{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"XQEMU is an open-source, cross-platform, low-level system emulator for the original Xbox and Sega Chihiro, built on the excellent QEMU project. Attention This project is still early in development. At this point, the intended user is a developer who is capable of acquiring the necessary ROM images, and compiling the project from sources. Project Status \u00b6 Audio does not work, and graphics are slow and buggy, but progress is being made! Please visit the issues page on GitHub for the current open and active tasks. Check out the screenshots to see the current state of things, or click here to get started running XQEMU! Get Involved \u00b6 If you are interested in helping to create a functional, accurate, and performant Xbox emulator, you are most welcome to contribute! There are opportunities for people of all skill levels to contribute. The project is hosted on GitHub . Keep up with the latest developments by chatting with us about development topics on #xqemu on irc.freenode.net, or on the IRC-bridged Discord server.","title":"Welcome"},{"location":"#project-status","text":"Audio does not work, and graphics are slow and buggy, but progress is being made! Please visit the issues page on GitHub for the current open and active tasks. Check out the screenshots to see the current state of things, or click here to get started running XQEMU!","title":"Project Status"},{"location":"#get-involved","text":"If you are interested in helping to create a functional, accurate, and performant Xbox emulator, you are most welcome to contribute! There are opportunities for people of all skill levels to contribute. The project is hosted on GitHub . Keep up with the latest developments by chatting with us about development topics on #xqemu on irc.freenode.net, or on the IRC-bridged Discord server.","title":"Get Involved"},{"location":"getting-started/","text":"Introduction \u00b6 XQEMU is a low-level, full-system emulator which emulates the actual hardware of the Xbox; this means that in order to actually run XQEMU, you must have a copy of the stuff that a real Xbox needs when it turns on: The MCPX Boot ROM image The flash ROM image (aka BIOS ) A properly-formatted hard disk drive image Game disc image(s) Unfortunately, distributing some of these items would violate copyright laws, so you'll need to acquire them on your own. Attention The XQEMU project does not endorse or promote piracy. We don't link to the copyrighted files, or discuss how to acquire them. The best way to acquire these files is to dump them from your real, physical Xbox . Please don't ask us how to get them. Tips \u00b6 MCPX Boot ROM Image \u00b6 MD5 (mcpx_1.0.bin) = d49c52a4102f6df7bcf8d0617ac475ed If your MCPX dump has an MD5 of 196a5f59a13382c185636e691d6c323d , you dumped it badly and it's a couple of bytes off. It should start with 0x33 0xC0 and end with 0x02 0xEE. Flash ROM Image (aka BIOS) \u00b6 Xbox 1.0 compatible bios (cromwell, 3944, 4034, 4036, ...). You can use a retail or debug image. Just like a real Xbox, running an unmodified retail bios will not allow booting unofficial software. People have reported most success using the modified retail \"COMPLEX 4627\" BIOS. Retail BIOS \u00b6 1M dump: MD5 (3944.bin) = e8b39b98cf775496c1c76e4f7756e6ed or sometimes 256k dump: MD5 (3944.bin) = 542c62cb976a4993c8c5027dff9638ce Debug BIOS \u00b6 People have reported success with the 'COMPLEX 4627' modified debug bios. It's convenient to note that this bios does not necessarily require a populated hard disk image to load an application from DVD (though an empty drive still needs to be attached), so you can skip the next step in some cases. v1.0.2 1M dump: MD5 (Complex_4627Debug.bin) = 19b5c6d3d42a707bba620634fe6d4baf or sometimes 1MB dump: MD5 (complex_4627debug.bin) = e8dd61cc6abdbd06aac185e371312dc1 Hard Disk Drive Image \u00b6 You have options: Option 1: Use a pre-built Xbox HDD image (recommended) \u00b6 You can use a pre-built 8G Xbox HDD image, free of any copyrighted content, and only containing a dummy dashboard. You can download this image from here! Note By design, this particular drive image does not contain the official Xbox dashboard, but instead contains only a dummy dashboard. Because of this, you may see an error message when starting XQEMU with an unmodified retail BIOS image due to the system failing to find a properly signed dashboard. If you would like to change your dashboard (perhaps to the official retail dashboard, or any alternative dashboard), or copy additional files over to the Xbox HDD, you can start XQEMU, using a modified BIOS image, and a disc containing an alternative dashboard. Then you can either install that dashboard, or connect to XQEMU using FTP to transfer your desired dashboard files to the HDD. Option 2: Image your real Xbox HDD \u00b6 This is the most authentic way to do it. Unlock your drive, connect it to a computer, and dd the entire contents of the drive straight to a file. This file can be used as-is with XQEMU. Option 3: Build a new HDD image from scratch \u00b6 You can also create an Xbox hard-disk image using XboxHDM. Directions on how to do this can be found here . Building XQEMU from Source \u00b6 Building on Windows \u00b6 Tip If you'd prefer to skip building from source and instead run a pre-built version of XQEMU for Windows, build artifacts are now available through Appveyor . Start by installing and setting up MSYS2 . Important After installing MSYS2, you'll need to open MSYS2 MinGW 64-bit to perform building. Otherwise, you may see build failures for cc.exe. Once MSYS2 has been installed, install all of the necessary packages by running: pacman -S git python2 make autoconf automake-wrapper \\ mingw-w64-x86_64-libtool mingw-w64-x86_64-gcc mingw-w64-x86_64-pkg-config \\ mingw-w64-x86_64-glib2 mingw-w64-x86_64-libepoxy mingw-w64-x86_64-SDL \\ mingw-w64-x86_64-SDL2 mingw-w64-x86_64-pixman Important Build failures have been reported when the path to the XQEMU root directory contains spaces. Please make sure to not have any whitespace in your build path. E.g: C:\\Users\\User Name\\xqemu\\build.sh will not work. Clone the repo: git clone https://github.com/xqemu/xqemu.git Then change directory: cd xqemu And build using the build script: sh ./build.sh Building on GNU/Linux \u00b6 Note These instructions were tested with Ubuntu 18.04. Depending on the Linux distribution being used, these instructions may vary. First enable deb-src via: sudo gedit /etc/apt/sources.list In this file, uncomment first deb-src line. Now refresh packages: sudo apt-get update Install build deps: sudo apt-get build-dep qemu sudo apt-get install git libsdl2-dev libepoxy-dev Then clone the repo: git clone https://github.com/xqemu/xqemu.git Then change directory: cd xqemu And build using the build script: ./build.sh Building on macOS \u00b6 First make sure you've installed the Homebrew package manager, then update and install necessary packages: brew update brew install libffi gettext glib pixman pkg-config autoconf pixman sdl2 libepoxy Clone the repo: git clone https://github.com/xqemu/xqemu.git Then change directory: cd xqemu And build using the build script: ./build.sh Launch XQEMU \u00b6 XQEMU is launchable via the command-line interface (though a GUI launcher is in development!) You can launch with the following command: ./i386-softmmu/qemu-system-i386 \\ -cpu pentium3 \\ -machine xbox,bootrom=$MCPX \\ -m 64 \\ -bios $BIOS \\ -drive index=0,media=disk,file=$HDD,locked \\ -drive index=1,media=cdrom,file=$DISC \\ -usb -device usb-xbox-gamepad Of course, on Windows the executable path will have a .exe extension. If launching a pre-built binary from AppVeyor, replace ./i386-softmmu/qemu-system-i386 with xqemu.exe . Replace the variables $MCPX , $BIOS , $HDD , and $DISC with the appropriate file paths or define them as variables in your shell. The Xbox boot animation sequence can be bypassed by adding the ,short-animation option to the -machine switch above.","title":"Getting Started"},{"location":"getting-started/#introduction","text":"XQEMU is a low-level, full-system emulator which emulates the actual hardware of the Xbox; this means that in order to actually run XQEMU, you must have a copy of the stuff that a real Xbox needs when it turns on: The MCPX Boot ROM image The flash ROM image (aka BIOS ) A properly-formatted hard disk drive image Game disc image(s) Unfortunately, distributing some of these items would violate copyright laws, so you'll need to acquire them on your own. Attention The XQEMU project does not endorse or promote piracy. We don't link to the copyrighted files, or discuss how to acquire them. The best way to acquire these files is to dump them from your real, physical Xbox . Please don't ask us how to get them.","title":"Introduction"},{"location":"getting-started/#tips","text":"","title":"Tips"},{"location":"getting-started/#mcpx-boot-rom-image","text":"MD5 (mcpx_1.0.bin) = d49c52a4102f6df7bcf8d0617ac475ed If your MCPX dump has an MD5 of 196a5f59a13382c185636e691d6c323d , you dumped it badly and it's a couple of bytes off. It should start with 0x33 0xC0 and end with 0x02 0xEE.","title":"MCPX Boot ROM Image"},{"location":"getting-started/#flash-rom-image-aka-bios","text":"Xbox 1.0 compatible bios (cromwell, 3944, 4034, 4036, ...). You can use a retail or debug image. Just like a real Xbox, running an unmodified retail bios will not allow booting unofficial software. People have reported most success using the modified retail \"COMPLEX 4627\" BIOS.","title":"Flash ROM Image (aka BIOS)"},{"location":"getting-started/#retail-bios","text":"1M dump: MD5 (3944.bin) = e8b39b98cf775496c1c76e4f7756e6ed or sometimes 256k dump: MD5 (3944.bin) = 542c62cb976a4993c8c5027dff9638ce","title":"Retail BIOS"},{"location":"getting-started/#debug-bios","text":"People have reported success with the 'COMPLEX 4627' modified debug bios. It's convenient to note that this bios does not necessarily require a populated hard disk image to load an application from DVD (though an empty drive still needs to be attached), so you can skip the next step in some cases. v1.0.2 1M dump: MD5 (Complex_4627Debug.bin) = 19b5c6d3d42a707bba620634fe6d4baf or sometimes 1MB dump: MD5 (complex_4627debug.bin) = e8dd61cc6abdbd06aac185e371312dc1","title":"Debug BIOS"},{"location":"getting-started/#hard-disk-drive-image","text":"You have options:","title":"Hard Disk Drive Image"},{"location":"getting-started/#option-1-use-a-pre-built-xbox-hdd-image-recommended","text":"You can use a pre-built 8G Xbox HDD image, free of any copyrighted content, and only containing a dummy dashboard. You can download this image from here! Note By design, this particular drive image does not contain the official Xbox dashboard, but instead contains only a dummy dashboard. Because of this, you may see an error message when starting XQEMU with an unmodified retail BIOS image due to the system failing to find a properly signed dashboard. If you would like to change your dashboard (perhaps to the official retail dashboard, or any alternative dashboard), or copy additional files over to the Xbox HDD, you can start XQEMU, using a modified BIOS image, and a disc containing an alternative dashboard. Then you can either install that dashboard, or connect to XQEMU using FTP to transfer your desired dashboard files to the HDD.","title":"Option 1: Use a pre-built Xbox HDD image (recommended)"},{"location":"getting-started/#option-2-image-your-real-xbox-hdd","text":"This is the most authentic way to do it. Unlock your drive, connect it to a computer, and dd the entire contents of the drive straight to a file. This file can be used as-is with XQEMU.","title":"Option 2: Image your real Xbox HDD"},{"location":"getting-started/#option-3-build-a-new-hdd-image-from-scratch","text":"You can also create an Xbox hard-disk image using XboxHDM. Directions on how to do this can be found here .","title":"Option 3: Build a new HDD image from scratch"},{"location":"getting-started/#building-xqemu-from-source","text":"","title":"Building XQEMU from Source"},{"location":"getting-started/#building-on-windows","text":"Tip If you'd prefer to skip building from source and instead run a pre-built version of XQEMU for Windows, build artifacts are now available through Appveyor . Start by installing and setting up MSYS2 . Important After installing MSYS2, you'll need to open MSYS2 MinGW 64-bit to perform building. Otherwise, you may see build failures for cc.exe. Once MSYS2 has been installed, install all of the necessary packages by running: pacman -S git python2 make autoconf automake-wrapper \\ mingw-w64-x86_64-libtool mingw-w64-x86_64-gcc mingw-w64-x86_64-pkg-config \\ mingw-w64-x86_64-glib2 mingw-w64-x86_64-libepoxy mingw-w64-x86_64-SDL \\ mingw-w64-x86_64-SDL2 mingw-w64-x86_64-pixman Important Build failures have been reported when the path to the XQEMU root directory contains spaces. Please make sure to not have any whitespace in your build path. E.g: C:\\Users\\User Name\\xqemu\\build.sh will not work. Clone the repo: git clone https://github.com/xqemu/xqemu.git Then change directory: cd xqemu And build using the build script: sh ./build.sh","title":"Building on Windows"},{"location":"getting-started/#building-on-gnulinux","text":"Note These instructions were tested with Ubuntu 18.04. Depending on the Linux distribution being used, these instructions may vary. First enable deb-src via: sudo gedit /etc/apt/sources.list In this file, uncomment first deb-src line. Now refresh packages: sudo apt-get update Install build deps: sudo apt-get build-dep qemu sudo apt-get install git libsdl2-dev libepoxy-dev Then clone the repo: git clone https://github.com/xqemu/xqemu.git Then change directory: cd xqemu And build using the build script: ./build.sh","title":"Building on GNU/Linux"},{"location":"getting-started/#building-on-macos","text":"First make sure you've installed the Homebrew package manager, then update and install necessary packages: brew update brew install libffi gettext glib pixman pkg-config autoconf pixman sdl2 libepoxy Clone the repo: git clone https://github.com/xqemu/xqemu.git Then change directory: cd xqemu And build using the build script: ./build.sh","title":"Building on macOS"},{"location":"getting-started/#launch-xqemu","text":"XQEMU is launchable via the command-line interface (though a GUI launcher is in development!) You can launch with the following command: ./i386-softmmu/qemu-system-i386 \\ -cpu pentium3 \\ -machine xbox,bootrom=$MCPX \\ -m 64 \\ -bios $BIOS \\ -drive index=0,media=disk,file=$HDD,locked \\ -drive index=1,media=cdrom,file=$DISC \\ -usb -device usb-xbox-gamepad Of course, on Windows the executable path will have a .exe extension. If launching a pre-built binary from AppVeyor, replace ./i386-softmmu/qemu-system-i386 with xqemu.exe . Replace the variables $MCPX , $BIOS , $HDD , and $DISC with the appropriate file paths or define them as variables in your shell. The Xbox boot animation sequence can be bypassed by adding the ,short-animation option to the -machine switch above.","title":"Launch XQEMU"},{"location":"input/","text":"XQEMU currently supports three options for connecting one or more virtual gamepads: Using an SDL2-supported input device to emulate an Xbox controller Using your PC's keyboard to emulate an Xbox controller Using a real Xbox controller with USB pass-thru (advanced) And like a real Xbox, you can connect multiple controllers! In all cases, start by making sure you have the -usb option specified on the XQEMU command line. Option 1: Use an SDL2-supported input device \u00b6 This method is known to work well with Xbox 360 and DualShock 4 controllers, with little to no setup required (with the exception of installing any required platform drivers). When starting XQEMU, simply pass in the following option: -device usb-xbox-gamepad-sdl,index=0 If you have multiple gamepads connected to your system, you can change the index of the connected device by changing index=X accordingly. Multiple gamepads can be connected by specifying the line above multiple times. Option 2: Use your PC keyboard \u00b6 If you do not have access to a real gamepad, you can use your PC's keyboard to emulate an Xbox gamepad. This works well in a pinch, and for for navigating through menus. When starting XQEMU, simply pass in the following option: -device usb-xbox-gamepad If you'd like, you can combine this device with the usb-xbox-gamepad-sdl device to emulate connecting two controllers. The input can't be configured at the moment but the following buttons are mapped: Xbox PC Keyboard S D W E X C Return Backspace DPad -Up \u2191 DPad -Down \u2193 DPad -Left \u2190 DPad -Right \u2192 Left Trigger Q Right Trigger R Left-Thumbstick -Up T Left-Thumbstick -Down G Left-Thumbstick -Left F Left-Thumbstick -Right H Left-Thumbstick -Press V Right-Thumbstick -Up I Right-Thumbstick -Down K Right-Thumbstick -Left J Right-Thumbstick -Right L Right-Thumbstick -Press M Option 3: USB-passthru (advanced) \u00b6 XQEMU has the option to forward USB Devices from the host to the guest. The input might be delayed, but it will support all features you'd expect. In theory even memory units or the communicator should work! You have 2 options to forward the xbox gamepad. You can either forward the hub or just the gamepad. To be able to forward any of the host devices you must take the following steps: Have an adapter cable (this one has not been tested yet!) or build one yourself* Have libusb installed Find the VID:PID (Vendor and Product ID) of the XID-Hub and/or the internal Gamepad device Make sure that libusb has the necessary permissions Important Please do not destroy original controllers. Instead buy an adapter cable, or a cheap break-away or extension cable. By cutting it in half you can create 2 USB adapters: 1. USB to Xbox + 2. Xbox to USB. You can still use your adapters as an extension cable for most XIDs (not working with lightguns). On Linux you can use lsusb for step 2. Step 3 involves adding a udev rule on most linux distributions. The udev rule (/etc/udev/rules.d/999-xbox- gamepad.rules) for a Controller-S could look like this: SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"045e\", ATTRS{idProduct}==\"0288\", GROUP=\"users\", MODE=\"660\" # Hub SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"045e\", ATTRS{idProduct}==\"0289\", GROUP=\"users\", MODE=\"660\" # Gamepad Hub-Forwarding \u00b6 To forward the entire hub of the controller we simply have to forward the hub to the emulated xbox. Example: -usb -device usb-host,bus=usb-bus.0,port=3,vendorid=0x45e,productid=0x288 Gamepad-Forwarding \u00b6 For Gamepad forwarding we create a virtual hub using QEMU and connect the XID gamepad device to port 2 of the emulated hub. Example: -usb -device usb-hub,bus=usb-bus.0,port=3 -device usb-host,vendorid=0x45e,productid=0x289,bus=usb-bus.0,port=3.2 Advanced Info \u00b6 About XID and QEMU USB \u00b6 The Xbox uses so called Xbox Input Devices (XID) . To connect a device to the virtual Xbox you must specify the driver for the emulated USB device and the port the device should connect to. The ports which can be used in XQEMU are: Xbox Port XQEMU USB-Port Player 1 bus=usb-bus.0,port=3 Player 2 bus=usb-bus.0,port=4 Player 3 bus=usb-bus.0,port=1 Player 4 bus=usb-bus.0,port=2 The XID is usually connected to Port 2 of the XID-hub. So if you have a hub for Player 1 at bus=usb-bus.0,port=3 , your gamepad-device would connect to bus =usb-bus.0,port=3.2 . To connect multiple gamepads you can simply specify multiple -device . To find out more about QEMU USB emulation you can read the QEMU User Documentation . Emulated XID \u00b6 There is XID emulation in XQEMU which emulates a very basic Duke Xbox Controller (VID: 0x045e, PID: 0x0202). To recreate the internal XID hub we use the existing QEMU \"usb-hub\" device. The actual XID emulation is provided by the \"xbox-gamepad\" device. Example: -usb -device usb-hub,bus=usb-bus.0,port=3 -device usb-xbox-gamepad,bus=usb-bus.0,port=3.2","title":"Input Devices"},{"location":"input/#option-1-use-an-sdl2-supported-input-device","text":"This method is known to work well with Xbox 360 and DualShock 4 controllers, with little to no setup required (with the exception of installing any required platform drivers). When starting XQEMU, simply pass in the following option: -device usb-xbox-gamepad-sdl,index=0 If you have multiple gamepads connected to your system, you can change the index of the connected device by changing index=X accordingly. Multiple gamepads can be connected by specifying the line above multiple times.","title":"Option 1: Use an SDL2-supported input device"},{"location":"input/#option-2-use-your-pc-keyboard","text":"If you do not have access to a real gamepad, you can use your PC's keyboard to emulate an Xbox gamepad. This works well in a pinch, and for for navigating through menus. When starting XQEMU, simply pass in the following option: -device usb-xbox-gamepad If you'd like, you can combine this device with the usb-xbox-gamepad-sdl device to emulate connecting two controllers. The input can't be configured at the moment but the following buttons are mapped: Xbox PC Keyboard S D W E X C Return Backspace DPad -Up \u2191 DPad -Down \u2193 DPad -Left \u2190 DPad -Right \u2192 Left Trigger Q Right Trigger R Left-Thumbstick -Up T Left-Thumbstick -Down G Left-Thumbstick -Left F Left-Thumbstick -Right H Left-Thumbstick -Press V Right-Thumbstick -Up I Right-Thumbstick -Down K Right-Thumbstick -Left J Right-Thumbstick -Right L Right-Thumbstick -Press M","title":"Option 2: Use your PC keyboard"},{"location":"input/#option-3-usb-passthru-advanced","text":"XQEMU has the option to forward USB Devices from the host to the guest. The input might be delayed, but it will support all features you'd expect. In theory even memory units or the communicator should work! You have 2 options to forward the xbox gamepad. You can either forward the hub or just the gamepad. To be able to forward any of the host devices you must take the following steps: Have an adapter cable (this one has not been tested yet!) or build one yourself* Have libusb installed Find the VID:PID (Vendor and Product ID) of the XID-Hub and/or the internal Gamepad device Make sure that libusb has the necessary permissions Important Please do not destroy original controllers. Instead buy an adapter cable, or a cheap break-away or extension cable. By cutting it in half you can create 2 USB adapters: 1. USB to Xbox + 2. Xbox to USB. You can still use your adapters as an extension cable for most XIDs (not working with lightguns). On Linux you can use lsusb for step 2. Step 3 involves adding a udev rule on most linux distributions. The udev rule (/etc/udev/rules.d/999-xbox- gamepad.rules) for a Controller-S could look like this: SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"045e\", ATTRS{idProduct}==\"0288\", GROUP=\"users\", MODE=\"660\" # Hub SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"045e\", ATTRS{idProduct}==\"0289\", GROUP=\"users\", MODE=\"660\" # Gamepad","title":"Option 3: USB-passthru (advanced)"},{"location":"input/#hub-forwarding","text":"To forward the entire hub of the controller we simply have to forward the hub to the emulated xbox. Example: -usb -device usb-host,bus=usb-bus.0,port=3,vendorid=0x45e,productid=0x288","title":"Hub-Forwarding"},{"location":"input/#gamepad-forwarding","text":"For Gamepad forwarding we create a virtual hub using QEMU and connect the XID gamepad device to port 2 of the emulated hub. Example: -usb -device usb-hub,bus=usb-bus.0,port=3 -device usb-host,vendorid=0x45e,productid=0x289,bus=usb-bus.0,port=3.2","title":"Gamepad-Forwarding"},{"location":"input/#advanced-info","text":"","title":"Advanced Info"},{"location":"input/#about-xid-and-qemu-usb","text":"The Xbox uses so called Xbox Input Devices (XID) . To connect a device to the virtual Xbox you must specify the driver for the emulated USB device and the port the device should connect to. The ports which can be used in XQEMU are: Xbox Port XQEMU USB-Port Player 1 bus=usb-bus.0,port=3 Player 2 bus=usb-bus.0,port=4 Player 3 bus=usb-bus.0,port=1 Player 4 bus=usb-bus.0,port=2 The XID is usually connected to Port 2 of the XID-hub. So if you have a hub for Player 1 at bus=usb-bus.0,port=3 , your gamepad-device would connect to bus =usb-bus.0,port=3.2 . To connect multiple gamepads you can simply specify multiple -device . To find out more about QEMU USB emulation you can read the QEMU User Documentation .","title":"About XID and QEMU USB"},{"location":"input/#emulated-xid","text":"There is XID emulation in XQEMU which emulates a very basic Duke Xbox Controller (VID: 0x045e, PID: 0x0202). To recreate the internal XID hub we use the existing QEMU \"usb-hub\" device. The actual XID emulation is provided by the \"xbox-gamepad\" device. Example: -usb -device usb-hub,bus=usb-bus.0,port=3 -device usb-xbox-gamepad,bus=usb-bus.0,port=3.2","title":"Emulated XID"},{"location":"networking/","text":"XQEMU emulates the Xbox network controller (nvnet), and being built on top of QEMU's robust networking support infrastructure, provides a flexible array of advanced network configuration options including: Socket networking, for connecting multiple running instances of XQEMU for possible networked game play. Tap networking, for bridging a physical network device for play with real Xboxes or other applications. User networking, for simple network use where only basic port-forwarding is required. This page contains some quick tips for common use cases regarding Xbox emulation. Additional details about networking configuration information is available in the official QEMU documentation . Bridged Networking \u00b6 Windows \u00b6 Requirements - OpenVPN TAP Driver (Scroll down to \u201cTap-Windows\u201d) Install the prerequisites then you\u2019ll need to manually bridge your main adapter and the newly created TAP adapter. This is easily done by going to Network & Sharing Center then Change adapter settings . The command line options are very similar to Linux however you\u2019ll need to change the ifname=tap0 to what ever Windows or yourself had set the name of the new TAP adapter to be. -net nic,model=nvnet -net tap,ifname=\"Ethernet 2\",script=no In this example the interface name is Ethernet 2 . Note When using the standalone/downloadable version of XQEMU you cannot have a space in the TAP adapter name. Linux \u00b6 Requirements - uml-utilities - bridge-utils By running this script via sudo before start-up of XQEMU you\u2019ll have set-up the bridge and tap adapters that are required for networking. You will however need to modify it slightly to include the main ethernet adaptor and the user account you\u2019ll be running XQEMU on. #!/bin/bash brctl addbr br0 ip addr flush dev <interface or eth0> brctl addif br0 <interface or eth0> tunctl -t tap0 -u <youruseracc> brctl addif br0 tap0 ifconfig <interface or eth0> up ifconfig tap0 up ifconfig br0 up dhclient -v br0 Once that runs and you don\u2019t see any errors you should be able to just run XQEMU with the additional command line option of -net nic,model=nvnet -net tap,ifname=tap0,script=no .","title":"Networking"},{"location":"networking/#bridged-networking","text":"","title":"Bridged Networking"},{"location":"networking/#windows","text":"Requirements - OpenVPN TAP Driver (Scroll down to \u201cTap-Windows\u201d) Install the prerequisites then you\u2019ll need to manually bridge your main adapter and the newly created TAP adapter. This is easily done by going to Network & Sharing Center then Change adapter settings . The command line options are very similar to Linux however you\u2019ll need to change the ifname=tap0 to what ever Windows or yourself had set the name of the new TAP adapter to be. -net nic,model=nvnet -net tap,ifname=\"Ethernet 2\",script=no In this example the interface name is Ethernet 2 . Note When using the standalone/downloadable version of XQEMU you cannot have a space in the TAP adapter name.","title":"Windows"},{"location":"networking/#linux","text":"Requirements - uml-utilities - bridge-utils By running this script via sudo before start-up of XQEMU you\u2019ll have set-up the bridge and tap adapters that are required for networking. You will however need to modify it slightly to include the main ethernet adaptor and the user account you\u2019ll be running XQEMU on. #!/bin/bash brctl addbr br0 ip addr flush dev <interface or eth0> brctl addif br0 <interface or eth0> tunctl -t tap0 -u <youruseracc> brctl addif br0 tap0 ifconfig <interface or eth0> up ifconfig tap0 up ifconfig br0 up dhclient -v br0 Once that runs and you don\u2019t see any errors you should be able to just run XQEMU with the additional command line option of -net nic,model=nvnet -net tap,ifname=tap0,script=no .","title":"Linux"},{"location":"screenshots/","text":"Disclaimer These screenshots represent the absolute best of what can currently be made to run and is not representative of most titles. All users are encouraged to help test XQEMU; and by recording screenshots, and even better video footage, you can help show the current state of the emulator and help us discover any problems. If you discover a problem, please report it! The John GodGames Emus channel on YouTube regularly provides several up-to-date videos of XQEMU running a large variety of games. You can see his XQEMU playlist here . Halo: Combat Evolved \u00b6 Campaign \u00b6 Note: Debug Build, Accelerated 4x Multiplayer: Blood Gulch (System Link) \u00b6 Multiplayer: Blood Gulch, Battle Creek (Split Screen) \u00b6 Note: Debug Build, Realtime, June 20 th Jet Set Radio Future \u00b6 Serious Sam II \u00b6 Commit 5d4058d . Recorded by John GodGames, thanks! Mechassult \u00b6 Taken by MayeulC, thanks! Tony Hawk's Pro Skater 2x \u00b6 Note: Debug Build, Realtime","title":"Screenshots"},{"location":"screenshots/#halo-combat-evolved","text":"","title":"Halo: Combat Evolved"},{"location":"screenshots/#campaign","text":"Note: Debug Build, Accelerated 4x","title":"Campaign"},{"location":"screenshots/#multiplayer-blood-gulch-system-link","text":"","title":"Multiplayer: Blood Gulch (System Link)"},{"location":"screenshots/#multiplayer-blood-gulch-battle-creek-split-screen","text":"Note: Debug Build, Realtime, June 20 th","title":"Multiplayer: Blood Gulch, Battle Creek (Split Screen)"},{"location":"screenshots/#jet-set-radio-future","text":"","title":"Jet Set Radio Future"},{"location":"screenshots/#serious-sam-ii","text":"Commit 5d4058d . Recorded by John GodGames, thanks!","title":"Serious Sam II"},{"location":"screenshots/#mechassult","text":"Taken by MayeulC, thanks!","title":"Mechassult"},{"location":"screenshots/#tony-hawks-pro-skater-2x","text":"Note: Debug Build, Realtime","title":"Tony Hawk's Pro Skater 2x"},{"location":"tips/","text":"Connect to an FTP server hosted inside XQEMU \u00b6 Writing files to your Xbox's HDD is currently a pain. It will be easy once the fatx driver has write capabilities, but until then you have the option of connecting over FTP to a server hosted inside xqemu. Run xqemu as normal, but add option to forward to port 21 inside VM as follows: -net nic,model=nvnet -net user,hostfwd=tcp:127.0.0.1:1021-:21 It's assumed you're using Filezilla. If not, look for the respective settings in your client. Fire up Filezilla and set the following options: Filezilla > Settings > Connection > FTP > Active mode Active mode IP, \"Use tho following IP address:\" 10.0.2.2 Make sure \"Don't use external IP address on local connections.\" is NOT checked Then create your new \"Site\" with IP address 127.0.0.1 and port 1021. Under Transfer Settings, check Active. Details for the curious \u00b6 FTP has two modes, passive and active. Passive mode involves the client first connecting to the server for control and then again on another port other for data. The client first connects, then the server gives it another address and port to connect to for data. The first problem with this is that the server reports to the client the only IP address that it knows (10.0.2.15) which is not correct for our needs--we need 127.0.0.1. That's alright because we can override this in Filezilla. The second problem is that we don't know which port the server is going to choose, so we can't forward it ahead of time. In active mode, the client first connects to the server, then the server connects to the client! The client needs to give the IP address for the server to connect to. By default, it will give your computer's IP address, but the guest cannot connect to using that IP. So instead we need to override this setting and provide the IP address that the guest should connect to to actually connect to the host, which is 10.0.2.2.","title":"Tips"},{"location":"tips/#connect-to-an-ftp-server-hosted-inside-xqemu","text":"Writing files to your Xbox's HDD is currently a pain. It will be easy once the fatx driver has write capabilities, but until then you have the option of connecting over FTP to a server hosted inside xqemu. Run xqemu as normal, but add option to forward to port 21 inside VM as follows: -net nic,model=nvnet -net user,hostfwd=tcp:127.0.0.1:1021-:21 It's assumed you're using Filezilla. If not, look for the respective settings in your client. Fire up Filezilla and set the following options: Filezilla > Settings > Connection > FTP > Active mode Active mode IP, \"Use tho following IP address:\" 10.0.2.2 Make sure \"Don't use external IP address on local connections.\" is NOT checked Then create your new \"Site\" with IP address 127.0.0.1 and port 1021. Under Transfer Settings, check Active.","title":"Connect to an FTP server hosted inside XQEMU"},{"location":"tips/#details-for-the-curious","text":"FTP has two modes, passive and active. Passive mode involves the client first connecting to the server for control and then again on another port other for data. The client first connects, then the server gives it another address and port to connect to for data. The first problem with this is that the server reports to the client the only IP address that it knows (10.0.2.15) which is not correct for our needs--we need 127.0.0.1. That's alright because we can override this in Filezilla. The second problem is that we don't know which port the server is going to choose, so we can't forward it ahead of time. In active mode, the client first connects to the server, then the server connects to the client! The client needs to give the IP address for the server to connect to. By default, it will give your computer's IP address, but the guest cannot connect to using that IP. So instead we need to override this setting and provide the IP address that the guest should connect to to actually connect to the host, which is 10.0.2.2.","title":"Details for the curious"},{"location":"developers/","text":"Debugging Tips \u00b6 QEMU can host a gdb stub! Launch with -s -S , and with gdb run target remote localhost:1234 Protip: You can also attach to it with IDA if you're so inclined. You can then load in a database if you export it as a IDC script! XQEMU can emulate a XDK serial port (which with a debug bios hosts KD, as in this and this )! Launch with something like -device lpc47m157 -serial unix:/tmp/xserial,server . With some effort you can wrestle the unix socket into a vm for with WinDbg. There's also a very barebones perl KD client in scripts/windpl apitrace is useful for tracking down rendering bugs. Debugging on macOS \u00b6 If your build of Qemu is crashing, I've found it easiest to use the Xcode debugger to look at stack traces. Fire up Xcode, create a project, edit the \"Scheme\" to run the xqemu binary, then click the run button. Xcode has a nice GUI for analyzing the stack frame and looking at local variables to quickly track down bugs. You can also attach to running processes.","title":"Welcome"},{"location":"developers/#debugging-tips","text":"QEMU can host a gdb stub! Launch with -s -S , and with gdb run target remote localhost:1234 Protip: You can also attach to it with IDA if you're so inclined. You can then load in a database if you export it as a IDC script! XQEMU can emulate a XDK serial port (which with a debug bios hosts KD, as in this and this )! Launch with something like -device lpc47m157 -serial unix:/tmp/xserial,server . With some effort you can wrestle the unix socket into a vm for with WinDbg. There's also a very barebones perl KD client in scripts/windpl apitrace is useful for tracking down rendering bugs.","title":"Debugging Tips"},{"location":"developers/#debugging-on-macos","text":"If your build of Qemu is crashing, I've found it easiest to use the Xcode debugger to look at stack traces. Fire up Xcode, create a project, edit the \"Scheme\" to run the xqemu binary, then click the run button. Xcode has a nice GUI for analyzing the stack frame and looking at local variables to quickly track down bugs. You can also attach to running processes.","title":"Debugging on macOS"}]}